from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import selectinload
from sqlalchemy import select
from fastapi import APIRouter, Request, Response
from src.api.models.shop_model.userShopModel import UserShop
from src.api.core.utility import Print
from src.api.core.middleware import handle_async_wrapper
from src.api.core.avatar_helper import get_user_avatar
from src.config import ACCESS_TOKEN_EXPIRE_MINUTES
from src.api.core.security import (
    create_access_token,
    decode_token,
    exist_user,
    hash_password,
    verify_password,
    verify_refresh_token,
)
from src.api.models.role_model.roleModel import Role
from src.api.models.role_model.userRoleModel import UserRole
from src.api.models.usersModel import RegisterUser, User, UserRead, LoginRequest
from src.api.models.couponModel import Coupon, CouponType
from src.api.core import (
    GetSession,
    api_response,
    requireSignin,
    requireAdmin,
    requirePermission,
)
from src.api.core.email_helper import send_email


router = APIRouter(tags=["Auth"])


def serialize_user_with_avatar(user: User) -> UserRead:
    """
    Serialize user and add avatar field
    """
    user_read = UserRead.model_validate(user)
    # Add avatar field using helper function
    user_read.avatar = get_user_avatar(user.image, user.name)
    return user_read


@router.post("/init", response_model=UserRead)
@handle_async_wrapper
def initialize_first_user(
    request: RegisterUser,
    session: GetSession,
):

    # Create first user with admin role
    hashed_password = hash_password(request.password)
    user = User(**request.model_dump())
    user = User(
        name=request.name,
        email=request.email,
        phone_no=request.phone_no,
        password=hashed_password,
        is_root=True,
    )
    session.add(user)
    session.flush()
    # Prevent rerun if roles already exist
    existing_roles = session.exec(select(Role)).all()
    if existing_roles:
        return api_response(
            400,
            "Initialization already done",
        )

    # Create roles
    admin_role = Role(
        name="root",
        slug="root",
        user_id=user.id,
        permissions=["all", "system:*"],
    )
    shop_admin_role = Role(
        name="Seller Roles",
        slug="shop_admin",
        user_id=user.id,
        permissions=["shop_admin", "role"],
    )

    session.add(admin_role)
    session.add(shop_admin_role)
    session.flush()  # get IDs without committing

    # Assign admin role to the user via UserRole
    user_role_link = UserRole(user_id=user.id, role_id=admin_role.id)
    session.add(user_role_link)

    session.commit()
    session.refresh(user)

    user_read = UserRead.model_validate(user)
    return api_response(
        200,
        "Initialized admin user and roles",
        user_read,
    )


@router.post("/register", response_model=dict)
def register_user(
    request: RegisterUser,
    response: Response,
    session: GetSession,
):
    db_user = exist_user(session, email=request.email)
    if db_user:
        return api_response(
            400,
            "This user already exist",
        )
    user = User(**request.model_dump())  # Similar to new User(req.body) in Mongoose
    hashed_password = hash_password(user.password)
    user.password = hashed_password
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to get updated fields (e.g., autogenerated ID)

    # Reload user with relationships (roles and shops)
    user = (
        session.exec(
            select(User)
            .options(
                selectinload(User.user_roles).selectinload(UserRole.role),
                selectinload(User.user_shops).selectinload(UserShop.shop),
            )
            .where(User.id == user.id)
        )
        .scalars()
        .first()
    )

    # Send welcome email notification with free shipping coupon if available
    try:
        # Query for active free shipping coupon
        current_time = datetime.now(timezone.utc)
        free_shipping_coupon = session.execute(
            select(Coupon)
            .where(Coupon.type == CouponType.FREE_SHIPPING)
            .where(Coupon.active_from <= current_time)
            .where(Coupon.expire_at >= current_time)
            .where(Coupon.deleted_at == None)
        ).scalars().first()

        # Prepare email replacements
        replacements = {
            "name": user.name,
            "customer_name": user.name,
            "email": user.email,
        }

        # Add coupon details if available
        if free_shipping_coupon:
            replacements.update({
                "coupon_code": free_shipping_coupon.code,
                "coupon_valid_from": free_shipping_coupon.active_from.strftime("%B %d, %Y"),
                "coupon_valid_to": free_shipping_coupon.expire_at.strftime("%B %d, %Y"),
                "coupon_minimum_amount": f"{free_shipping_coupon.minimum_cart_amount:.2f}",
                "coupon_code_text":"Code:",
                "date":"Date:",
                "min_amount_text":"Minimum Cart Amount:"
            })
        else:
            # Provide empty values if no coupon available
            replacements.update({
                "coupon_code": "",
                "coupon_valid_from": "",
                "coupon_valid_to": "",
                "coupon_minimum_amount": "",
                "coupon_code_text":"",
                "date":"",
                "min_amount_text":""
            })

        send_email(
            to_email=user.email,
            email_template_id=3,  # Use appropriate template ID for user registration
            replacements=replacements
        )
    except Exception as e:
        # Log email error but don't fail registration
        print(f"Failed to send registration email: {e}")

    # Generate tokens and prepare response (same as login)
    roles = user.role_names
    permissions = user.permissions
    shops = [{"id": shop.id, "name": shop.name} for shop in user.shops]

    user_data = {
        "id": user.id,
        "email": user.email,
        "is_root": user.is_root or False,
        "roles": roles,
        "permissions": permissions,
        "shops": shops,
    }

    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )

    user_read = serialize_user_with_avatar(user)

    # Set refresh token cookie
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )

    content = {
        "message": "User registered successfully",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "User Registered Successfully", content)


@router.post("/login", response_model=dict)
def login_user(
    request: LoginRequest,
    response: Response,
    session: GetSession,
):

    user = (
        session.exec(
            select(User)
            .options(
                selectinload(User.user_roles).selectinload(UserRole.role),
                selectinload(User.user_shops).selectinload(
                    UserShop.shop
                ),  # ðŸ‘ˆ eager load shops
            )
            .where(User.email == request.email)
        )
        .scalars()
        .first()
    )
   
    if not user:
        return api_response(404, "User not found")
    if not verify_password(request.password, user.password):
        return api_response(401, "Incorrect password")
    if not user.is_active:
        return api_response(403, "User account is disabled")

    # Use properties instead of user.roles
    roles = user.role_names
    permissions = user.permissions

    # ðŸ”¥ Extract shops
    shops = [{"id": shop.id, "name": shop.name} for shop in user.shops]

    user_data = {
        "id": user.id,
        "email": user.email,
        "is_root": user.is_root or False,
        "roles": roles,
        "permissions": permissions,
        "shops": shops,
    }
    # Print(user_data)
    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )

    user_read = serialize_user_with_avatar(user)
    print(f"user:{user_read}")
    # cookie will test in postman and frontend only with tag credential:true
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )
    content = {
        "message": "Login successful",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Login successful", content)


@router.post(
    "/refresh",
)
def refresh_token(
    refresh_token: str,
    response: Response,
    session: GetSession,
):
    if not refresh_token:
        return api_response(401, "Missing refresh token")

    payload = verify_refresh_token(refresh_token)
    if not payload:
        return api_response(401, "Invalid refresh token")

    token_data = decode_token(refresh_token)
    if not token_data:
        return api_response(401, "Invalid refresh token")

    # Fetch fresh user data from database
    user = (
        session.exec(
            select(User)
            .options(
                selectinload(User.user_roles).selectinload(UserRole.role),
                selectinload(User.user_shops).selectinload(UserShop.shop),
            )
            .where(User.id == token_data.get("user", {}).get("id"))
        )
        .scalars()
        .first()
    )

    if not user:
        return api_response(404, "User not found")

    if not user.is_active:
        return api_response(403, "User account is disabled")

    # Build user data for token
    roles = user.role_names
    permissions = user.permissions
    shops = [{"id": shop.id, "name": shop.name} for shop in user.shops]

    user_data = {
        "id": user.id,
        "email": user.email,
        "is_root": user.is_root or False,
        "roles": roles,
        "permissions": permissions,
        "shops": shops,
    }

    access_token = create_access_token(user_data=user_data)
    new_refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )

    user_read = serialize_user_with_avatar(user)

    # Set refresh token cookie
    response.set_cookie(
        key="refresh_token",
        value=new_refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )

    content = {
        "message": "Token refreshed successfully",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": new_refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Token refreshed successfully", content)


@router.post("/logout")
def logout(response: Response):
    response.delete_cookie("refresh_token")
    response.delete_cookie("access_token")
    return {"message": "Logged out"}


@router.get("/testauth", response_model=dict)
def test_auth(
    user: requireSignin,
):
    return api_response(
        200,
        "Token is valid",
        {"user": user},
    )


@router.get("/testadmin")
def get_admin_data(
    user: requireAdmin,
):

    return {"message": f"Hello Admin {user['email']}", "user": user}


@router.get("/testpermission")
def get_admin_data(
    user=requirePermission("system:*"),
):
    return {"message": f"Hello Admin {user}"}
