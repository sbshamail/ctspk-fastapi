from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import selectinload
from sqlalchemy import select
from fastapi import APIRouter, Request, Response
from src.api.core.utility import Print
from src.api.core.decorator import handle_async_wrapper
from src.config import ACCESS_TOKEN_EXPIRE_MINUTES
from src.api.core.security import (
    create_access_token,
    decode_token,
    exist_user,
    hash_password,
    verify_password,
    verify_refresh_token,
)
from src.api.models.role_model.roleModel import Role
from src.api.models.role_model.userRoleModel import UserRole
from src.api.models.usersModel import RegisterUser, User, UserRead, LoginRequest
from src.api.core import (
    GetSession,
    api_response,
    requireSignin,
    requireAdmin,
    requirePermission,
)


router = APIRouter(tags=["Auth"])


@router.post("/init", response_model=UserRead)
@handle_async_wrapper
def initialize_first_user(
    request: RegisterUser,
    session: GetSession,
):

    # Create first user with admin role
    hashed_password = hash_password(request.password)
    user = User(**request.model_dump())
    user = User(
        name=request.name,
        email=request.email,
        phone_no=request.phone_no,
        password=hashed_password,
    )
    session.add(user)
    session.flush()
    # Prevent rerun if roles already exist
    existing_roles = session.exec(select(Role)).all()
    if existing_roles:
        return api_response(
            400,
            "Initialization already done",
        )

    # Create roles
    admin_role = Role(
        name="root",
        user_id=user.id,
        permissions=["all"],
    )
    shop_admin_role = Role(
        name="shop_admin",
        user_id=user.id,
        permissions=["shop", "role"],
    )

    session.add(admin_role)
    session.add(shop_admin_role)
    session.flush()  # get IDs without committing

    # Assign admin role to the user via UserRole
    user_role_link = UserRole(user_id=user.id, role_id=admin_role.id)
    session.add(user_role_link)

    session.commit()
    session.refresh(user)

    user_read = UserRead.model_validate(user)
    return api_response(
        200,
        "Initialized admin user and roles",
        user_read,
    )


@router.post("/register", response_model=UserRead)
@handle_async_wrapper
def register_user(
    request: RegisterUser,
    session: GetSession,
):
    db_user = exist_user(session, email=request.email)
    if db_user:
        return api_response(
            400,
            "This user already exist",
        )
    user = User(**request.model_dump())  # Similar to new User(req.body) in Mongoose
    hashed_password = hash_password(user.password)
    user.password = hashed_password
    session.add(user)
    session.commit()
    session.refresh(user)  # Refresh to get updated fields (e.g., autogenerated ID)
    user_read = UserRead.model_validate(user)  # ✅ Convert User → UserRead
    return api_response(
        200,
        "User Registered Successfully",
        user_read,
    )


@router.post("/login", response_model=dict)
def login_user(
    request: LoginRequest,
    response: Response,
    session: GetSession,
):
    user = (
        session.exec(
            select(User)
            .options(selectinload(User.user_roles).selectinload(UserRole.role))
            .where(User.email == request.email)
        )
        .scalars()
        .first()
    )
    if not user:
        return api_response(404, "User not found")
    if not verify_password(request.password, user.password):
        return api_response(401, "Incorrect password")
    if not user.is_active:
        return api_response(403, "User account is disabled")

    # Use properties instead of user.roles
    roles = user.role_names
    permissions = user.permissions

    Print(user)

    user_data = {
        "id": user.id,
        "email": user.email,
        "roles": roles,
        "permissions": permissions,
    }
    access_token = create_access_token(user_data=user_data)
    refresh_token = create_access_token(user_data=user_data, refresh=True)

    exp_time = datetime.now(timezone.utc) + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )

    user_read = UserRead.model_validate(user)
    # cookie will test in postman and frontend only with tag credential:true
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        samesite="strict",
        max_age=30 * 24 * 60 * 60,  # 30 days
    )
    content = {
        "message": "Login successful",
        "token_type": "bearer",
        "access_token": access_token,
        "refresh_token": refresh_token,
        "user": user_read,
        "exp": exp_time.isoformat(),
    }

    return api_response(200, "Login successful", content)


@router.post(
    "/refresh",
)
def refresh_token(
    refresh_token: str,
):
    if not refresh_token:
        api_response(401, "Missing refresh token")

    payload = verify_refresh_token(refresh_token)
    if not payload:
        raise api_response(401, "Invalid refresh token")
    user = decode_token(refresh_token)
    # user = UserRead.model_validate(db_user)
    access_token = create_access_token(user)
    new_refresh_token = create_access_token(user_data=user, refresh=True)

    return api_response(
        200,
        "Refresh",
        {
            "access_token": access_token,
            "refresh_token": new_refresh_token,
            "user": user,
        },
    )


@router.post("/logout")
def logout(response: Response):
    response.delete_cookie("refresh_token")
    response.delete_cookie("access_token")
    return {"message": "Logged out"}


@router.get("/testauth", response_model=dict)
def test_auth(
    user: requireSignin,
):
    return api_response(
        200,
        "Token is valid",
        {"user": user},
    )


@router.get("/testadmin")
def get_admin_data(
    user: requireAdmin,
):
    return {"message": f"Hello Admin {user['email']}"}


@router.get("/testpermission")
def get_admin_data(
    user=requirePermission("all"),
):
    return {"message": f"Hello Admin {user}"}
